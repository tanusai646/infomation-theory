\documentclass[documentclass]{jsarticle}
\usepackage[top=25truemm,bottom=25truemm,left=20truemm,right=20truemm]{geometry}
\usepackage{listings, jlisting, color}
\usepackage[dvipdfmx]{graphicx}
\usepackage{pdfpages}
\usepackage{amsmath}
\usepackage{amssymb, latexsym}
\usepackage{mathtools}
\usepackage{multirow}
\usepackage{color}
\usepackage{ulem}
\usepackage{here}
\usepackage{wrapfig}
\usepackage{tikz}
\usepackage{color}
\usetikzlibrary{intersections, calc, arrows, positioning, arrows.meta}


\newcommand{\Add}[1]{\textcolor{red}{#1}}
\newcommand{\Erase}[1]{\textcolor{red}{\sout{\textcolor{black}{#1}}}}
\newcommand{\ctext}[1]{\raise0.2ex\hbox{\textcircled{\scriptsize{#1}}}}
\newcommand{\red}[1]{\textcolor{red}{#1}}

\lstset{
  basicstyle={\small},
  breaklines=true,
  frame=single,
  tabsize=3,
  numbers=left
}

\begin{document}
\title{情報理論 第14回 計算機演習}
\author{222C1021 今村優希}
\maketitle

\newpage

\section*{演習1}
\subsection*{演習1-1}
IMのASCIIコードを符号化する．

\begin{itemize}
  \item I : 0100 1001
  \item M : 0100 1101
\end{itemize}

(7,4)ハミング符号なので，4bitずつ符号化を行う．
また，検査ビットを式\ref*{sq:1-1}と設定する．
\begin{equation}
  \left\{ \,
    \begin{aligned}
      &c_1 = a_1 \oplus a_2 \oplus a_3 \\
      &c_2 = a_2 \oplus a_3 \oplus a_4 \\
      &c_3 = a_1 \oplus a_2 \oplus a_4 
    \end{aligned}
  \right.
  \label{sq:1-1}
\end{equation}

\paragraph*{0100の符号化}
式\ref*{sq:1-1}を利用して$c_1$から$c_3$まで求めると，
\begin{align*}
  c_1 = 1, c_2 = 1, c_3 = 1
\end{align*}
と検査ビットを計算できる．したがって，送信符号は(0100111)である．

\paragraph*{1001の符号化}
式\ref*{sq:1-1}を利用して，
\begin{align*}
  c_1 = 1, c_2 = 1, c_3 = 0
\end{align*}
と計算ビット計算できる．したがって，送信符号は(1001110)である．

\paragraph*{0100の符号化}
式\ref*{sq:1-1}を利用して，
\begin{align*}
  c_1 = 1, c_2 = 1, c_3 = 1
\end{align*}
と検査ビットが計算できる．したがって，送信符号は(0100111)である．

\paragraph*{1101の符号化}
式\ref*{sq:1-1}を利用して，
\begin{align*}
  c_1 = 0, c_2 = 0, c_3 = 1
\end{align*}
と検査ビット計算できる．したがって，送信符号は(1101001)である．

以上から，送信される符号は，(0100111 1001110 0100111 1101001)となる．

\subsection*{演習1-2}
自分の学籍番号の下一桁+1番目と11番目のbitに誤りが発生すると仮定するので，受信符号は
\begin{center}
  (0\red{0}00111 100\red{0}110 0100111 1101001)
\end{center}
である．誤りが発生した部分を赤文字で表している．
\newpage

また，シーケンスは
\begin{equation}
  \left\{ \,
    \begin{aligned}
      &s_1 = a_1 \oplus a_2 \oplus a_3 \oplus c_1\\
      &s_2 = a_2 \oplus a_3 \oplus a_4 \oplus c_2\\
      &s_3 = a_1 \oplus a_2 \oplus a_4 \oplus c_3
    \end{aligned}
  \right.
  \label{sq:1-2}
\end{equation}
で計算できる．
このシーケンスから得られるエラーテーブルを表\ref*{tb:1-1}に表す．
\begin{table}[H]
  \begin{center}
    \caption{エラーテーブル}
    \label{tb:1-1}
    \begin{tabular}{|ccccccc|c|} \hline
     $e_1$ & $e_2$ & $e_3$ & $e_4$ & $e_5$ & $e_6$ & $e_7$ & $s_1 s_2 s_3$ \\ \hline
     0 & 0 & 0 & 0 & 0 & 0 & 0 & 000 \\ 
     1 & 0 & 0 & 0 & 0 & 0 & 0 & 101 \\ 
     0 & 1 & 0 & 0 & 0 & 0 & 0 & 111 \\ 
     0 & 0 & 1 & 0 & 0 & 0 & 0 & 110 \\ 
     0 & 0 & 0 & 1 & 0 & 0 & 0 & 011 \\ 
     0 & 0 & 0 & 0 & 1 & 0 & 0 & 100 \\ 
     0 & 0 & 0 & 0 & 0 & 1 & 0 & 010 \\ 
     0 & 0 & 0 & 0 & 0 & 0 & 1 & 001 \\ \hline
    \end{tabular}
  \end{center}
\end{table}

\paragraph*{0000111の復号化}
式\ref*{sq:1-2}を利用して，得られるシーケンスは，
\begin{align*}
  s_1 = 1, s_2 = 1, s_3 = 1
\end{align*}
である．エラーテーブルから2bit目が誤りだと分かるので訂正して，(0100)が正しい符号である．

\paragraph*{1000110の復号化}
式\ref*{sq:1-2}を利用して，得られるシーケンスは，
\begin{align*}
  s_0 = 1, s_2 = 1, s_3 = 1
\end{align*}
である．エラーテーブルから4bit目が誤りだと分かるので訂正して，(1001)が正しい符号である．

\paragraph*{0100111 と 1101001の復号化}
\paragraph*{0000111の復号化}
式\ref*{sq:1-2}を利用して，得られるシーケンスは，0100111と1101001どちらも
\begin{align*}
  s_1 = 0, s_2 = 0, s_3 = 0
\end{align*}
である．シーケンスがすべて0ではないので正しく受信できている．
したがって，(0100)と(1101)が受信符号である．

よって，復号化して得られる符号は，(0100 1001 0100 1101)である．

\subsection*{演習1-3}

\newpage

\section*{演習2}
\subsection*{演習2-1}
BSCの相互情報量$I(X;Y)$の計算を行う．$P_X(0)=r$とし，誤り率は$p$で表現する．
% BSCの状態を以下のfigureで表現できそうだったら行う．
\begin{figure}[H]
  \begin{center}
    \begin{tikzpicture}[node/.style={draw, circle, font=\small, inner sep=1pt}]
      \node[node](s1) {};
      \node[node, below left = 3cm and 2cm of s1](s2) {};
      \node[node, below right  = 3cm and 2cm of s1](s3) {};
  
      \path[->, >=stealth]
        (s1) edge[loop right, in=20, out=100, looseness=4] node{0.8} (s1)
        (s1) edge[left, bend right=10] node{0.1} (s2)
        (s1) edge[left, bend right=10] node{0.1} (s3)
        (s2) edge[right, bend right=10] node{0.5} (s1)
        (s2) edge[loop left, in=225, out=135, looseness=4] node{0.4} (s2)
        (s2) edge[right, bend right=10] node{0.1} (s3)
        (s3) edge[right, bend right=10] node{0.5} (s1)
        (s3) edge[right, bend right=10] node{0.5} (s2);
    \end{tikzpicture}
  \end{center}
  \caption{状態遷移図}
  \label{fig:2-1}
\end{figure}

まずは，結合確率を求める．
\begin{align}
  P_{X,Y}(0,0) &= r(1-p) \\ \label{sq:1-3}
  P_{X,Y}(0,1) &= rp \\
  P_{X,Y}(1,0) &= (1-r)p \\
  P_{X,Y}(1,1) &= (1-r)(1-p) 
\end{align}
それから，周辺確率を求めると，
\begin{align}
  P_X(0) &= r \\ 
  P_X(1) &= 1-r\\
  P_Y(0) &= P_{X,Y}(0,0) + P_{X,Y}(1,0) = r(1-p) + (1-r)p\\
  P_Y(1) &= P_{X,Y}(0,1) + P_{X,Y}(1,1) = rp + (1-r)(1-p) \label{sq:1-4}
\end{align}
となる．式\ref*{sq:1-3}から\ref*{sq:1-4}を用いて条件付き確率を求める．
\begin{align}
  P_{X|Y}(0|0) = \dfrac{P_{X,Y}(0,0)}{P_Y(0)} = \dfrac{r(1-p)}{r(1-p) + (1-r)p} \\
  P_{X|Y}(1|0) = \dfrac{P_{X,Y}(1,0)}{P_Y(0)} = \dfrac{(1-r)p}{r(1-p) + (1-r)p} \\
  P_{X|Y}(0|1) = \dfrac{P_{X,Y}(0,1)}{P_Y(1)} = \dfrac{rp}{rp + (1-r)(1-p)} \\
  P_{X|Y}(1|1) = \dfrac{P_{X,Y}(1,1)}{P_Y(1)} = \dfrac{(1-r)(1-p)}{rp + (1-r)(1-p)} \label{sq:1-7}
\end{align}
次に条件付きエントロピーを求める．条件付きエントロピーは，
\begin{align}
  H(X|Y) &=P_Y(0)H(X|Y=0) + P_Y(1)H(X|Y=1)\\
  \begin{split}
    & = P_Y(0)\big(-P_{X|Y}(0|0) \log_2{P_{X|Y}(0|0)} -P_{X|Y}(1|0) \log_2{P_{X|Y}(1|0)}\big)\\
    & \qquad + P_Y(1)\big(-P_{X|Y}(0|1) \log_2{P_{X|Y}(0|1)} -P_{X|Y}(1|1) \log_2{P_{X|Y}(1|1)}\big) 
  \end{split}
  \\
  \begin{split}
    &= - P_{X,Y}(0,0)\log_2{P_{X|Y}(0|0)} - -P_{X,Y}(1,0)\log_2{P_{X|Y}(1|0)} \\
    & \qquad - P_{X,Y}(0,1)\log_2{P_{X|Y}(0|1)} - -P_{X,Y}(1,1)\log_2{P_{X|Y}(1|1)} \label{sq:1-6}
  \end{split}
\end{align}
と変形できる．
式\ref*{sq:1-6}に，式\ref*{sq:1-3}から\ref*{sq:1-7}を代入していくと，条件付きエントロピー$H(X|Y)$は，
\begin{align}
  \begin{split}
    H(X|Y) &= -r(1-p) \log_2 \dfrac{r(1-p)}{r(1-p) + (1-r)p} - \big(r(1-p) + (1-r)p\big) \log_2 \dfrac{rp}{rp + (1-r)(1-p)}  \\
    & \qquad - rp \log_2 \dfrac{(1-r)p}{r(1-p) + (1-r)p} - \big(rp + (1-r)(1-p)\big) \log_2 \dfrac{(1-r)(1-p)}{rp + (1-r)(1-p)}
  \end{split}
\end{align}
となる．さらに，事前エントロピー$H(X)$は，
\begin{align}
  H(X) = -r \log_2 r - (1-r) \log_2 (1-r)
\end{align}
で求めることができる．したがって，相互情報量$I(X;Y)$は，
\begin{align}
  I(X;Y) &= H(X) - H(X|Y)\\
  \begin{split}
    &= -r \log_2 r - (1-r) \log_2 (1-r)\\
    & \qquad-\Big(-r(1-p) \log_2 \dfrac{r(1-p)}{r(1-p) + (1-r)p} - \big(r(1-p) + (1-r)p\big) \log_2 \dfrac{rp}{rp + (1-r)(1-p)}  \\
    & \qquad \quad - rp \log_2 \dfrac{(1-r)p}{r(1-p) + (1-r)p} - \big(rp + (1-r)(1-p)\big) \log_2 \dfrac{(1-r)(1-p)}{rp + (1-r)(1-p)}\Big)
  \end{split}
  \\
  &= p \log_2{p} + (1-p) \log_2{(1-p)} - (r+p-2rp) \log_2{(r+p-2rp)} - (1-r-p+2rp) \log_2{(1-r-p+2rp)} \label{sq:1-8}
\end{align}
と算出することができる．教科書等では$H_f(p)$などとまとめていたが，続く設問のプログラムで式\ref*{sq:1-8}を直接使用するのでまとめる行為は行わなかった．

\subsection*{演習2-2}
$r = \dfrac{1}{2}$としたときの$I(X;Y)$と$p$の関係のグラフをMatlabで作成する．
まず，演習2-1で算出した$I(X;Y)$に対して，$r = \dfrac{1}{2}$を代入すると，
\begin{align}
  H(X;Y) = 1 + p \log_2{p} + (1-p) \log_2{(1-p)}
\end{align}
となるので，この式を利用してMatlabでプログラムの作成を行った．
ソースコード\ref*{sc:2-1}では，xをエラー確率として，0から1まで0.001刻みで遷移させている．
最後にその値をグラフにプロットしたものが図\ref*{fig:2-2}である．
横軸がエラー確率，縦軸が相互情報量を表している．

\lstinputlisting[caption=エラー確率と相互情報量の関係のプログラム \label{sc:2-1}]{code/ensyuu2_2.m}

\begin{figure}[H]
  \begin{center}
    \includegraphics*[]{figure/2-1.png}
  \end{center}
  \caption{エラー確率と相互情報量の関係}
  \label{fig:2-2}
\end{figure}


\subsection*{演習2-3}
演習2-2から，通信路容量の最大値を求める．
通信路容量は，
\begin{align}
  C = \max{I(X;Y)} = \max{\{H(X) - H(X|Y)\}}
\end{align}
で求めることができる．
したがって，\ref*{fig:2-2}のグラフから見ると，$C = \max_{P(X)}I(X;Y)$は，$p=1,0$のときに最大値の1を取ることがわかる．
よって，通信路容量の最大値は1である．
\subsection*{演習2-4}
Matlabを用いて$r = \dfrac{1}{2}$となる情報源を作成し，BSCを通過させるようなプログラムを作成し，その結果について考察を行った．

\subsubsection*{プログラム}
作成したプログラムは，ソースコード\ref*{sc:2-2}である．
このプログラムで情報源の発生，BSCの通過から相互情報量の値を出力することができる．

プログラムの流れに関して説明をする．
15行目から送信符号を生成し，BSCに通過させている．
送信するビット数が100,000bitなので1から100,00までfor文を回している．
16行目でxに0から100まで整数の乱数を発生させている．18行目以降のif文ないで，生成された値を2のmodを取ることで送信符号の0,1を作っている．
乱数なので，このとき$r = \dfrac{1}{2}$であると考える．
次に，確率用の0から1以下の乱数を生成させている．
この乱数が設定しているエラー確率より大きいか小さいかを判断することでBSCを通過のモデルを実現している．
35行目以降は，相互情報量を求めるために，結合確率や周辺確率，条件付きエントロピーの計算を行っている．

\lstinputlisting[caption=BSC通過プログラム \label{sc:2-2}]{code/ensyuu2_4.m}

\subsubsection*{出力結果}

\newpage

\section*{演習3}
\subsection*{演習3-1}
50回遷移するように設計したプログラムは，ソースコード3である．
11行目のStudentIDを021に設定した．
また，50回遷移するから，NIterationを「50」に，さらに62行目も「1:50」に変更した．
このプログラムをmatlabで実行した結果が，ソースコード4である．
また，遷移した状態の回数を棒グラフで表したものが図\ref*{fig:3-1}である．
\begin{lstlisting}[caption=状態変化を見るプログラム]
  % 九州工業大学情報工学部情報・通信工学科3年
% 情報理論 演習課題1 演習3
% 2024/05/10 黒崎正行
% 2024/05/10 今村優希一部変更

clear;                                 
clearvars -global;                    
close all;                            
clc;                                   
%% Parameter setting
StudentID = 021;            % 学籍番号の下３桁に変更すること
seed = StudentID;           % 学籍番号を乱数のシード値に設定
rng(seed);                  % 乱数のシード値の設定

CurrentState = 1;           % 現在の状態 (初期状態1)
NextState = 1;              % 次の状態 

NIteration = 50;          % 繰返し回数

StateHist = zeros(1, NIteration);

%% Start simulation
for ite = 1: NIteration

    Transition = rand;                                    % ランダム値の生成
    StateHist(ite) = CurrentState;                        % 現在の状態の番号を格納

    switch CurrentState
        case 1                                            % 状態1における動作を記述
            if Transition < 0.8                           % 0.8の確率で状態1に遷移
                NextState = 1;
            elseif Transition >= 0.8 && Transition < 0.9  % 0.9-0.8=0.1の確率で状態2に遷移
                NextState = 2;
            else                                          % 0.1の確率で状態3に遷移
                NextState = 3;
            end
        case 2                                            % 状態2における動作を記述
            if Transition < 0.5                           % 0.5の確率で状態1に遷移
                NextState = 1;
            elseif Transition >= 0.5 && Transition < 0.9  % 0.9-0.5=0.4確率で状態2に遷移
                NextState = 2;
            else                                          % 0.1の確率で状態2に遷移
                NextState = 3;
            end
        case 3                                            % 状態3における動作を記述
            if Transition < 0.5                           % 0.3の確率で状態1に遷移
                NextState = 1;
            elseif Transition >= 0.5 && Transition < 1.0  % 1.0-0.5=0.5の確率で状態2に遷移
                NextState = 2;
            else                                          % 0の確率で状態2に遷移
                NextState = 3;
            end
        otherwise
            NextState=1;
    end
    CurrentState = NextState;
end

%% Evaluation
% 最初から50回の遷移を表示
disp('State History');
disp(StateHist(1:50));

% ヒストグラムのグラフの表示
h = histogram(StateHist);

% 頻度の表示
%
 disp('State Frequency');
 disp('State   Count   Percent');
 fprintf('   S1, %6d, %8.3f %%\n', h.Values(1),h.Values(1)/NIteration*100);
 fprintf('   S2, %6d, %8.3f %%\n', h.Values(2),h.Values(2)/NIteration*100);
 fprintf('   S3, %6d, %8.3f %%\n', h.Values(3),h.Values(3)/NIteration*100);

\end{lstlisting}

\begin{lstlisting}[caption=ソースコード3を実行したときの結果]
  State History
  1 列から 20 列

     1     1     1     1     1     1     1     1     1     1     1     1     2     1     1     1     2     2     3     2

  21 列から 40 列

     1     1     1     1     2     3     2     2     1     1     1     1     1     1     1     1     1     2     1     1

  41 列から 50 列

     1     1     1     2     2     2     1     2     2     2

State Frequency
State   Count   Percent
   S1,     34,   68.000 %
   S2,     14,   28.000 %
   S3,      2,    4.000 %
\end{lstlisting}

\begin{figure}[H]
  \begin{center}
    \includegraphics*[scale=0.6]{figure/3-1.png}
  \end{center}
  \caption{50回遷移させたときの各状態に遷移した回数}
  \label{fig:3-1}
\end{figure}

\subsection*{演習3-2}
利用したプログラムは演習3-1で使用したソースコード3を一部変更したものである．
1000回遷移するから，NIterationを「1000」に，さらに62行目も「1:1000」に変更した．
出力はソースコード5で表しており，遷移した状態の回数を棒グラフで表したものが図\ref*{fig:3-2}である．
\begin{lstlisting}[caption=1000回遷移させるためのプログラム]
  % 九州工業大学情報工学部情報・通信工学科3年
% 情報理論 演習課題1 演習3
% 2024/05/10 黒崎正行
% 2024/05/10 今村優希改変

clear;                                 
clearvars -global;                    
close all;                            
clc;                                   
%% Parameter setting
StudentID = 021;            % 学籍番号の下３桁に変更すること
seed = StudentID;           % 学籍番号を乱数のシード値に設定
rng(seed);                  % 乱数のシード値の設定

CurrentState = 1;           % 現在の状態 (初期状態1)
NextState = 1;              % 次の状態 

NIteration = 1000;          % 繰返し回数

StateHist = zeros(1, NIteration);

%% Start simulation
for ite = 1: NIteration

    Transition = rand;                                      % ランダム値の生成
    StateHist(ite) = CurrentState;                          % 現在の状態の番号を格納

    switch CurrentState
        case 1                                              % 状態1における動作を記述
            if Transition < 0.8                             % 0.8の確率で状態1に遷移
                NextState = 1;
            elseif Transition >= 0.8 && Transition < 0.9    % 0.9-0.8=0.1の確率で状態2に遷移
                NextState = 2;
            else                                            % 0.1の確率で状態3に遷移
                NextState = 3;
            end
        case 2                                              % 状態2における動作を記述
            if Transition < 0.5                             % 0.5の確率で状態1に遷移
                NextState = 1;
            elseif Transition >= 0.5 && Transition < 0.9    % 0.9-0.5=0.4確率で状態2に遷移
                NextState = 2;
            else                                            % 0.1の確率で状態2に遷移
                NextState = 3;
            end
        case 3                                              % 状態3における動作を記述
            if Transition < 0.5                             % 0.3の確率で状態1に遷移
                NextState = 1;
            elseif Transition >= 0.5 && Transition < 1.0    % 1.0-0.5=0.5の確率で状態2に遷移
                NextState = 2;
            else                                            % 0の確率で状態2に遷移
                NextState = 3;
            end
        otherwise
            NextState=1;
    end
    CurrentState = NextState;
end

%% Evaluation
% 最初から1000回の遷移を表示
disp('State History');
disp(StateHist(1:1000));

% ヒストグラムのグラフの表示
h = histogram(StateHist);

% 頻度の表示
%
 disp('State Frequency');
 disp('State   Count   Percent');
 fprintf('   S1, %6d, %8.3f %%\n', h.Values(1),h.Values(1)/NIteration*100);
 fprintf('   S2, %6d, %8.3f %%\n', h.Values(2),h.Values(2)/NIteration*100);
 fprintf('   S3, %6d, %8.3f %%\n', h.Values(3),h.Values(3)/NIteration*100);

\end{lstlisting}

\begin{lstlisting}[caption=ソースコード5を実行した際の結果]
  State History
  1 列から 20 列

     1     1     1     1     1     1     1     1     1     1     1     1     2     1     1     1     2     2     3     2

  21 列から 40 列

     1     1     1     1     2     3     2     2     1     1     1     1     1     1     1     1     1     2     1     1

  % 一部省略 %

  941 列から 960 列

     1     2     2     1     1     1     1     2     2     2     1     3     2     1     1     2     2     2     1     1

  961 列から 980 列

     1     3     2     1     1     2     2     1     1     2     2     1     3     2     2     2     2     1     1     2

  981 列から 1,000 列

     2     1     2     2     1     1     1     1     1     1     3     1     1     1     1     1     1     1     2     2

State Frequency
State   Count   Percent
   S1,    713,   71.300 %
   S2,    195,   19.500 %
   S3,     92,    9.200 %
\end{lstlisting}

\begin{figure}[H]
  \begin{center}
    \includegraphics*[scale=0.6]{figure/3-2.png}
  \end{center}
  \caption{1000回遷移させたときの各状態に遷移した回数}
  \label{fig:3-2}
\end{figure}

\subsection*{演習3-3}
演習3-2の遷移する回数と初期状態を変更した以下の条件で実行した際の各確率に関して調べた．
\paragraph*{初期状態$S_2$で50回遷移させたとき}
\begin{align*}
 P(S_1) &= 66.0\%\\
 P(S_2) &= 30.0\%\\
 P(S_3) &= 4.0\%
\end{align*}
\paragraph*{初期状態$S_2$で1000回遷移させたとき}
\begin{align*}
  P(S_1) &= 71.2\%\\
  P(S_2) &= 19.6\%\\
  P(S_3) &= 9.2\%
 \end{align*}
\paragraph*{初期状態$S_3$で50回遷移させたとき}
\begin{align*}
  P(S_1) &= 66.0\%\\
  P(S_2) &= 28.0\%\\
  P(S_3) &= 6.0\%
 \end{align*}
\paragraph*{初期状態$S_3$で1000回遷移させたとき}
\begin{align*}
  P(S_1) &= 71.2\%\\
  P(S_2) &= 19.5\%\\
  P(S_3) &= 9.3\%
\end{align*}

\subsection*{演習3-4}
演習2と演習3の結果を見比べてみると，状態遷移を1000回遷移させたときの$S_1$から$S_3$それぞれに遷移する確率が演習2で求めた定常確率とほぼ同じである事がわかる．
したがって，定常確率$P(S_1)$はある時間において，状態$S_1$の確率も表しているとも言えると考える．

また，初期状態を変更したとしても各状態の発生確率はさほど変わらなかったことから，初期状態は発生確率に関係ないことがわかる．

\newpage

\section*{演習4}
\subsection*{演習4-1}
ZIPのアルゴリズムに関して説明する．データ圧縮は一般に「2段ロケット方式」が用いられている．
「2段ロケット方式」とはその名の通り，1段目の圧縮と2段目の圧縮が存在し，その2つをうまく組み合わせることで効率的な圧縮を実現している．

ZIPに関しては，1段目に「スライド辞書」方式を使用している．
辞書と呼ばれるエリアを確保して，その中から事前に出現した文字を探し出し，「その文字列と同じであること」を出力することで文字列を圧縮することができる．
1段目で文字列を圧縮できたので，2段目には「ハフマン符号」を用いてビット列にする．
ハフマン符号とは，可変長のビットを割り当てるアルゴリズムである．
出現頻度が多ければ多いほど短い符号に割り当て，その逆の場合は比較的長い符号が割り当てられる．
この事によって，文字列をビットに変換し圧縮することが可能である．

ただ，上記のハフマン符号の処理を実現するためには複数の支援機能が必要である．
まずは，符号として処理するためにビット単位に変換するための「ビットストリーム」，
単位にデータを溜め込んで頻度表を作る「バッファブロック」，
そのバッファブロク単位にビット長テーブル(頻度表)を入出力する処理も必要である．

ZIP圧縮の流れとしては，まずはスライド辞書に読み込まれ，一致文字列と不一致文字列の大きく2種類のコードに分解され，バッファにブロックに溜め込まれる．
その後，一定量溜め込まれたコードはハフマン符号期によってビットパターンに変換される．
そのビットパターンは可変長なので，ビットストリームを使ってバイト単位に出力することで圧縮が完了する．
これらの流れを図示したものが図\ref*{fig:4-1}である．
\begin{figure}[H]
  \begin{center}
    \includegraphics*[scale=0.5]{figure/4-1.png}
  \end{center}
  \caption{ZIP圧縮アルゴリズムのモデル}
  \label{fig:4-1}
\end{figure}

\subsection*{演習4-2}
用意したファイルとその容量は以下の表\ref*{tb:4-1}の通りである．
テキストファイルの文字コードはUTF-8である．
\begin{table}[H]
  \begin{center}
    \caption{用意したファイルとその容量}
    \label{tb:4-1}
    \begin{tabular}{|cc|} \hline
     ファイルの種類 & ファイルの容量 \\ \hline
     .txt    & 3,204,504バイト \\
     .jpeg   & 149,984 バイト \\
     .mp3    & 74,196,385 バイト \\ \hline
    \end{tabular}
  \end{center}
\end{table}

\subsection*{演習4-3}
zip圧縮はwindows標準搭載のものを使用した．
圧縮後の容量をまとめたものが表\ref*{tb:4-2}である．
\begin{table}[h]
  \begin{center}
    \caption{用意したファイルとその容量}
    \label{tb:4-2}
    \begin{tabular}{|cc|} \hline
     ファイルの種類 & 圧縮ファイルの容量 \\ \hline
     .txt    & 3,240 バイト \\
     .jpeg   & 137,581  バイト \\
     .mp3    & 73,670,682  バイト \\ \hline
    \end{tabular}
  \end{center}
\end{table}

\subsection*{演習4-4}
圧縮率の比較を行う．比較した結果を表\ref*{tb:4-3}にまとめた．
圧縮率は
\begin{align*}
  圧縮率 = \dfrac{圧縮前のファイル容量}{圧縮後のファイル容量}
\end{align*}
で計算を行った．
\begin{table}[h]
  \begin{center}
    \caption{それぞれのファイルの圧縮率}
    \label{tb:4-3}
    \begin{tabular}{|cc|} \hline
     ファイルの種類 & 圧縮率 \\ \hline
     .txt    &  $1.011 \times 10^{-3}$\\
     .jpeg   & $0.917$ \\
     .mp3    & $0.993$ \\ \hline
    \end{tabular}
  \end{center}
\end{table}

\subsection*{演習4-5}
演習4-2から4をもとに，それぞれのファイル圧縮率に関して考察を行う．
演習4-1のZIP圧縮のアルゴリズムから，ZIP圧縮は文字列に対して非常に有効であると考えられる．
したがって，テキストファイルの圧縮率が非常に小さいことから，効率的に圧縮が行われていることが伺える．
一方，文字列に対してjpgやmp3の圧縮率は非常に大きく，効率的に圧縮が行われてないと思われる．
jpegもmp3もすでに圧縮されたファイルであり，文字列ではないのでZIPでの圧縮が効率的に行われなかったと考えられる．

追記(一回消えたのでバックアップからの出力で一部間違いがあるかも)

\newpage
\begin{thebibliography}{9}
  \bibitem{1} 奥村晴彦 山崎敏,LHAとZIP : 圧縮アルゴリズム×プログラミング入門, ソフトバンク パブリッシング株式会社, 東京, 2003.
  \bibitem{2} SHARP, デジタルカメラで撮影した画像をZIP形式に圧縮してもファイルサイズが小さくならない Ｑ＆Ａ情報（文書番号：107790）\\
  https://cs.sharp.co.jp/faq/qa?qid=107790, 参照:20245/19.
\end{thebibliography}
\end{document}